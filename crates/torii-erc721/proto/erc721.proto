syntax = "proto3";

package torii.sinks.erc721;

// ===== Core Messages =====

// NFT Transfer event
message NftTransfer {
    // Token contract address (32 bytes)
    bytes token = 1;
    // NFT token ID as U256 (variable length, up to 32 bytes)
    bytes token_id = 2;
    // Sender address (32 bytes)
    bytes from = 3;
    // Receiver address (32 bytes)
    bytes to = 4;
    // Block number where the transfer occurred
    uint64 block_number = 5;
    // Transaction hash (32 bytes)
    bytes tx_hash = 6;
    // Unix timestamp of the block
    int64 timestamp = 7;
}

// NFT Approval event (single token approval)
message NftApproval {
    // Token contract address (32 bytes)
    bytes token = 1;
    // NFT token ID as U256 (variable length, up to 32 bytes)
    bytes token_id = 2;
    // Owner address (32 bytes)
    bytes owner = 3;
    // Approved address (32 bytes)
    bytes approved = 4;
    // Block number where the approval occurred
    uint64 block_number = 5;
    // Transaction hash (32 bytes)
    bytes tx_hash = 6;
    // Unix timestamp of the block
    int64 timestamp = 7;
}

// Operator Approval event (approval for all tokens)
message OperatorApproval {
    // Token contract address (32 bytes)
    bytes token = 1;
    // Owner address (32 bytes)
    bytes owner = 2;
    // Operator address (32 bytes)
    bytes operator = 3;
    // Whether the operator is approved
    bool approved = 4;
    // Block number where the approval occurred
    uint64 block_number = 5;
    // Transaction hash (32 bytes)
    bytes tx_hash = 6;
    // Unix timestamp of the block
    int64 timestamp = 7;
}

// Current NFT ownership state
message Ownership {
    // Token contract address (32 bytes)
    bytes token = 1;
    // NFT token ID as U256 (variable length, up to 32 bytes)
    bytes token_id = 2;
    // Current owner address (32 bytes)
    bytes owner = 3;
    // Block number when ownership was last updated
    uint64 block_number = 4;
}

// ===== Filters =====

// Filter for transfer queries and subscriptions
message TransferFilter {
    // Matches from OR to (wallet-centric filter)
    optional bytes wallet = 1;
    // Exact from address match
    optional bytes from = 2;
    // Exact to address match
    optional bytes to = 3;
    // Token contract whitelist (empty = all tokens)
    repeated bytes tokens = 4;
    // Specific NFT token IDs to filter
    repeated bytes token_ids = 5;
    // Minimum block number (inclusive)
    optional uint64 block_from = 6;
    // Maximum block number (inclusive)
    optional uint64 block_to = 7;
}

// Filter for ownership queries
message OwnershipFilter {
    // Owner address to filter by
    optional bytes owner = 1;
    // Token contract whitelist (empty = all tokens)
    repeated bytes tokens = 2;
    // Specific NFT token IDs to filter
    repeated bytes token_ids = 3;
}

// ===== Pagination =====

// Cursor for paginated queries (opaque to clients)
message Cursor {
    // Block number for cursor position
    uint64 block_number = 1;
    // Row ID within block for tie-breaking
    int64 id = 2;
}

// ===== Query RPCs =====

// Request for GetTransfers RPC
message GetTransfersRequest {
    // Filter criteria
    TransferFilter filter = 1;
    // Cursor from previous response (omit for first page)
    optional Cursor cursor = 2;
    // Maximum number of transfers to return (default: 100, max: 1000)
    uint32 limit = 3;
}

// Response for GetTransfers RPC
message GetTransfersResponse {
    // List of transfers matching the filter
    repeated NftTransfer transfers = 1;
    // Cursor for next page (absent if no more results)
    optional Cursor next_cursor = 2;
}

// Request for GetOwnership RPC
message GetOwnershipRequest {
    // Filter criteria
    OwnershipFilter filter = 1;
    // Cursor from previous response (omit for first page)
    optional Cursor cursor = 2;
    // Maximum number of ownership records to return (default: 100, max: 1000)
    uint32 limit = 3;
}

// Response for GetOwnership RPC
message GetOwnershipResponse {
    // List of ownership records matching the filter
    repeated Ownership ownership = 1;
    // Cursor for next page (absent if no more results)
    optional Cursor next_cursor = 2;
}

// Request for GetOwner RPC
message GetOwnerRequest {
    // Token contract address (32 bytes)
    bytes token = 1;
    // NFT token ID as U256 (variable length, up to 32 bytes)
    bytes token_id = 2;
}

// Response for GetOwner RPC
message GetOwnerResponse {
    // Current owner address (absent if not found)
    optional bytes owner = 1;
}

// ===== Attribute Search =====

// OR-within-key filter values; AND logic is applied across keys.
message AttributeFilter {
    // Attribute key / trait_type
    string key = 1;
    // Accepted values for this key (OR)
    repeated string values = 2;
}

// Facet count entry for UI filtering
message AttributeFacetCount {
    // Attribute key / trait_type
    string key = 1;
    // Attribute value
    string value = 2;
    // Number of matching tokens containing this key/value
    uint64 count = 3;
}

// Request for QueryTokensByAttributes RPC
message QueryTokensByAttributesRequest {
    // Token contract address (required, 32 bytes)
    bytes token = 1;
    // Attribute filters (AND across entries)
    repeated AttributeFilter filters = 2;
    // Cursor token_id (exclusive) for pagination
    optional bytes cursor_token_id = 3;
    // Maximum number of token IDs to return (default: 100, max: 1000)
    uint32 limit = 4;
    // Include facet counts in response
    bool include_facets = 5;
    // Maximum number of facet rows to return (default: 100, max: 1000)
    uint32 facet_limit = 6;
}

// Response for QueryTokensByAttributes RPC
message QueryTokensByAttributesResponse {
    // Matched token IDs (U256 bytes)
    repeated bytes token_ids = 1;
    // Cursor for next page (absent if no more results)
    optional bytes next_cursor_token_id = 2;
    // Total number of matched token IDs (without pagination)
    uint64 total_hits = 3;
    // Facet counts over the matched set
    repeated AttributeFacetCount facets = 4;
}

// ===== Subscription RPCs =====

// Request for SubscribeTransfers RPC
message SubscribeTransfersRequest {
    // Client identifier for logging/debugging
    string client_id = 1;
    // Filter criteria for transfers
    TransferFilter filter = 2;
}

// Update message for transfer subscriptions
message TransferUpdate {
    // The transfer event
    NftTransfer transfer = 1;
    // Unix timestamp when the update was generated
    int64 timestamp = 2;
}

// ===== Token Metadata =====

// Request for GetTokenMetadata RPC
message GetTokenMetadataRequest {
    // Token contract address (32 bytes). If empty, returns all tokens.
    optional bytes token = 1;
    // Cursor token (exclusive). Only used when token is not set.
    optional bytes cursor = 2;
    // Maximum number of entries to return (default: 100, max: 1000).
    uint32 limit = 3;
}

// Token metadata entry
message TokenMetadataEntry {
    // Token contract address (32 bytes)
    bytes token = 1;
    // Token name (e.g. "Loot Survivor")
    optional string name = 2;
    // Token symbol (e.g. "LS")
    optional string symbol = 3;
    // Total supply as U256 (variable length, up to 32 bytes)
    optional bytes total_supply = 4;
}

// Response for GetTokenMetadata RPC
message GetTokenMetadataResponse {
    // Token metadata entries
    repeated TokenMetadataEntry tokens = 1;
    // Cursor for next page (absent if no more results).
    optional bytes next_cursor = 2;
}

// ===== Collection APIs =====

// Token row returned by collection endpoints
message CollectionToken {
    // Token contract address (32 bytes)
    bytes contract_address = 1;
    // Token ID as U256 bytes
    bytes token_id = 2;
    // On-chain token URI (if known)
    optional string uri = 3;
    // Raw metadata JSON (if cached)
    optional string metadata_json = 4;
    // Resolved static image URL (if requested)
    optional string image_url = 5;
}

// Summary for one trait key
message TraitSummary {
    // Attribute key / trait_type
    string key = 1;
    // Number of distinct values for this key
    uint64 value_count = 2;
}

// Request for GetCollectionTokens RPC
message GetCollectionTokensRequest {
    // Token contract address (required)
    bytes contract_address = 1;
    // Attribute filters (AND across entries)
    repeated AttributeFilter filters = 2;
    // Cursor token_id (exclusive) for pagination
    optional bytes cursor_token_id = 3;
    // Maximum number of token IDs to return (default: 100, max: 1000)
    uint32 limit = 4;
    // Include facet counts in response
    bool include_facets = 5;
    // Maximum number of facet rows to return (default: 100, max: 1000)
    uint32 facet_limit = 6;
    // Include image URLs in each token row
    bool include_images = 7;
}

// Response for GetCollectionTokens RPC
message GetCollectionTokensResponse {
    // Token rows for the collection page
    repeated CollectionToken tokens = 1;
    // Cursor for next page (absent if no more results)
    optional bytes next_cursor_token_id = 2;
    // Total number of matched token IDs (without pagination)
    uint64 total_hits = 3;
    // Facet counts over the matched set
    repeated AttributeFacetCount facets = 4;
}

// Request for GetCollectionTraitFacets RPC
message GetCollectionTraitFacetsRequest {
    // Token contract address (required)
    bytes contract_address = 1;
    // Attribute filters (AND across entries)
    repeated AttributeFilter filters = 2;
    // Maximum number of facet rows to return (default: 100, max: 1000)
    uint32 facet_limit = 3;
}

// Response for GetCollectionTraitFacets RPC
message GetCollectionTraitFacetsResponse {
    // Facet counts over the matched set
    repeated AttributeFacetCount facets = 1;
    // Summary rows grouped by key
    repeated TraitSummary traits = 2;
    // Total number of matched token IDs (without pagination)
    uint64 total_hits = 3;
}

// Optional per-contract filters for overview endpoint
message ContractAttributeFilters {
    // Token contract address
    bytes contract_address = 1;
    // Filters applied to this contract only
    repeated AttributeFilter filters = 2;
}

// Grouped overview block for one contract
message ContractCollectionOverview {
    // Token contract address
    bytes contract_address = 1;
    // Token rows for this contract
    repeated CollectionToken tokens = 2;
    // Cursor for next page (absent if no more results)
    optional bytes next_cursor_token_id = 3;
    // Total number of matched token IDs (without pagination)
    uint64 total_hits = 4;
    // Facet counts over matched set
    repeated AttributeFacetCount facets = 5;
    // Summary rows grouped by key
    repeated TraitSummary traits = 6;
}

// Request for GetCollectionOverview RPC
message GetCollectionOverviewRequest {
    // One or more contracts to query
    repeated bytes contract_addresses = 1;
    // Maximum tokens per contract block (default: 50, max: 200)
    uint32 per_contract_limit = 2;
    // Include facet counts per contract
    bool include_facets = 3;
    // Maximum number of facet rows per contract (default: 100, max: 1000)
    uint32 facet_limit = 4;
    // Include image URLs in token rows
    bool include_images = 5;
    // Optional contract-specific filters
    repeated ContractAttributeFilters contract_filters = 7;
}

// Response for GetCollectionOverview RPC
message GetCollectionOverviewResponse {
    // One overview block per requested contract
    repeated ContractCollectionOverview overviews = 1;
}

// ===== Stats =====

// Request for GetStats RPC
message GetStatsRequest {}

// Response for GetStats RPC
message GetStatsResponse {
    // Total number of transfers indexed
    uint64 total_transfers = 1;
    // Number of unique token contracts indexed
    uint64 unique_tokens = 2;
    // Number of unique NFTs indexed
    uint64 unique_nfts = 3;
    // Latest block number indexed
    uint64 latest_block = 4;
}

// ===== Service =====

// ERC721 indexer service providing queries and subscriptions
service Erc721 {
    // Query historical transfers with filtering and pagination
    rpc GetTransfers(GetTransfersRequest) returns (GetTransfersResponse);

    // Query current NFT ownership with filtering and pagination
    rpc GetOwnership(GetOwnershipRequest) returns (GetOwnershipResponse);

    // Get the current owner of a specific NFT
    rpc GetOwner(GetOwnerRequest) returns (GetOwnerResponse);

    // Get token metadata (name, symbol)
    rpc GetTokenMetadata(GetTokenMetadataRequest) returns (GetTokenMetadataResponse);

    // Query token IDs by flattened metadata attributes (supports intersections)
    rpc QueryTokensByAttributes(QueryTokensByAttributesRequest) returns (QueryTokensByAttributesResponse);

    // Fetch collection token rows with pagination and optional facets
    rpc GetCollectionTokens(GetCollectionTokensRequest) returns (GetCollectionTokensResponse);

    // Fetch trait facets and trait summaries for a collection
    rpc GetCollectionTraitFacets(GetCollectionTraitFacetsRequest) returns (GetCollectionTraitFacetsResponse);

    // Fetch grouped overview blocks for one or more contracts
    rpc GetCollectionOverview(GetCollectionOverviewRequest) returns (GetCollectionOverviewResponse);

    // Subscribe to real-time transfer events with filtering
    rpc SubscribeTransfers(SubscribeTransfersRequest) returns (stream TransferUpdate);

    // Get indexer statistics
    rpc GetStats(GetStatsRequest) returns (GetStatsResponse);
}
