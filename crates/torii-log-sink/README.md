# Torii Log Sink

A demonstration sink for Torii that collects and stores log entries from blockchain events.

## Features

This sink demonstrates all three Torii extension points:

1. **EventBus** - Publishes to central topic-based subscriptions (via `torii.Torii/Subscribe`)
2. **gRPC Service** - Provides `torii.sinks.log.LogSink` service with:
   - `QueryLogs` - Query recent logs
   - `SubscribeLogs` - Real-time streaming subscription
3. **REST HTTP** - Exposes:
   - `GET /logs?limit=N` - Get recent logs (default: 5)
   - `GET /logs/count` - Get total log count

## Usage

```rust
use std::sync::Arc;
use torii::{ToriiConfig, run};
use torii_log_sink::{LogDecoder, LogSink};
use tonic::transport::Server;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 1. Create sink
    let log_sink = LogSink::new(100); // Max 100 logs in memory

    // 2. Get the gRPC service implementation
    let log_grpc_service = log_sink.get_grpc_service_impl();

    // 3. Build gRPC router with log sink service
    let grpc_router = {
        use torii_log_sink::proto::log_sink_server::LogSinkServer;

        Server::builder()
            .accept_http1(true)
            .add_service(tonic_web::enable(LogSinkServer::new((*log_grpc_service).clone())))
    };

    // 4. Create decoder
    let log_decoder = Arc::new(LogDecoder::new(None)); // No filter

    // 5. Configure and run Torii
    let config = ToriiConfig::builder()
        .port(8080)
        .add_sink_boxed(Box::new(log_sink))
        .add_decoder(log_decoder)
        .with_grpc_router(grpc_router)
        .build();

    run(config).await
}
```

## Protobuf Code Generation

The gRPC service definitions are in `proto/log.proto`. The Rust code is automatically generated during build.

### Generated Files

- **Location**: `src/generated/torii.sinks.log.rs`
- **Generated by**: `build.rs` (runs automatically with `cargo build`)
- **Includes**: Service trait, message types, client/server stubs

### How to Regenerate

The protobuf code is automatically regenerated when:

1. **Building the crate**: `cargo build -p torii-log-sink`
2. **Proto file changes**: Any modification to `proto/log.proto` triggers regeneration

### Manual Regeneration

If you need to force regeneration:

```bash
# Clean and rebuild
cargo clean -p torii-log-sink
cargo build -p torii-log-sink

# Or touch the proto file to trigger rebuild
touch crates/torii-log-sink/proto/log.proto
cargo build -p torii-log-sink
```

### Build Process

The `build.rs` script:

1. Creates `src/generated/` directory if it doesn't exist
2. Configures `tonic-build` to generate server code (no client)
3. Compiles `proto/log.proto` into Rust code
4. Outputs to `src/generated/torii.sinks.log.rs`

See `build.rs` for implementation details.

## Architecture

```
┌─────────────────────────────────────────────────┐
│              LogSink                            │
├─────────────────────────────────────────────────┤
│                                                 │
│  ┌────────────────┐      ┌─────────────────┐  │
│  │  LogDecoder    │─────▶│  LogEntry       │  │
│  │                │      │  (in-memory)    │  │
│  │  Events → Logs │      │  VecDeque       │  │
│  └────────────────┘      └─────────────────┘  │
│                                  │              │
│                    ┌─────────────┼──────────┐  │
│                    │             │          │  │
│                    ▼             ▼          ▼  │
│           ┌──────────────┐  ┌────────┐  ┌────┐│
│           │  EventBus    │  │  gRPC  │  │HTTP││
│           │  (central)   │  │  APIs  │  │API ││
│           └──────────────┘  └────────┘  └────┘│
│                                                 │
└─────────────────────────────────────────────────┘
```

## Storage

- **In-Memory**: Uses `VecDeque<ProtoLogEntry>` with configurable max size
- **Thread-Safe**: Wrapped in `Arc<RwLock<_>>` for concurrent access
- **Circular Buffer**: Oldest logs are evicted when max size is reached

## gRPC Service Registration

Due to Rust's type system limitations, gRPC services must be registered by the user:

```rust
// User code (e.g., main.rs or examples/)
use torii_log_sink::proto::log_sink_server::LogSinkServer;
use tonic::transport::Server;

let log_sink = LogSink::new(100);
let service = log_sink.get_grpc_service_impl();

let grpc_router = Server::builder()
    .accept_http1(true)
    .add_service(tonic_web::enable(LogSinkServer::new((*service).clone())));

// Pass router to Torii
let config = ToriiConfig::builder()
    .add_sink_boxed(Box::new(log_sink))
    .with_grpc_router(grpc_router)
    .build();
```

This pattern keeps all gRPC services on the same port while maintaining type safety.

## Testing

```bash
# Build
cargo build -p torii-log-sink

# Run tests
cargo test -p torii-log-sink

# Test gRPC (with server running)
grpcurl -plaintext localhost:8080 torii.sinks.log.LogSink/QueryLogs

# Test HTTP
curl http://localhost:8080/logs?limit=5
curl http://localhost:8080/logs/count
```

## See Also

- **Example**: `examples/multi_sink_example` - Multi-sink usage (SqlSink + LogSink)
- **SQL Sink**: `crates/torii-sql-sink` - Similar architecture with SQLite storage
