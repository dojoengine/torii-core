// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies,output_typescript,use_proto_field_name,client_generic
// @generated from protobuf file "sinks/sql.proto" (package "torii.sinks.sql", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Starknet Felt252 - 32 bytes, efficiently encoded
 *
 * @generated from protobuf message torii.sinks.sql.Felt252
 */
export interface Felt252 {
    /**
     * Raw 32-byte field element (NOT hex string!)
     *
     * @generated from protobuf field: bytes value = 1
     */
    value: Uint8Array;
}
/**
 * SQL operation event (insert/update)
 *
 * @generated from protobuf message torii.sinks.sql.SqlOperation
 */
export interface SqlOperation {
    /**
     * Table name
     *
     * @generated from protobuf field: string table = 1
     */
    table: string;
    /**
     * Operation type (insert, update, delete, etc.)
     *
     * @generated from protobuf field: string operation = 2
     */
    operation: string;
    /**
     * Operation value
     *
     * @generated from protobuf field: uint64 value = 3
     */
    value: bigint;
}
/**
 * SQL filter for subscriptions
 *
 * @generated from protobuf message torii.sinks.sql.SqlFilter
 */
export interface SqlFilter {
    /**
     * Optional table name filter
     *
     * @generated from protobuf field: optional string table = 1
     */
    table?: string;
    /**
     * Block number range
     *
     * @generated from protobuf field: optional uint64 block_number_gte = 2
     */
    block_number_gte?: bigint;
    /**
     * @generated from protobuf field: optional uint64 block_number_lte = 3
     */
    block_number_lte?: bigint;
}
// ===== SqlSink gRPC Service =====

/**
 * Request to execute a SQL query
 *
 * @generated from protobuf message torii.sinks.sql.QueryRequest
 */
export interface QueryRequest {
    /**
     * SQL query string
     *
     * @generated from protobuf field: string query = 1
     */
    query: string;
    /**
     * Optional limit for result set
     *
     * @generated from protobuf field: optional int32 limit = 2
     */
    limit?: number;
}
/**
 * A single row in the query result
 *
 * @generated from protobuf message torii.sinks.sql.QueryRow
 */
export interface QueryRow {
    /**
     * Column name -> value mapping (as JSON strings for flexibility)
     *
     * @generated from protobuf field: map<string, string> columns = 1
     */
    columns: {
        [key: string]: string;
    };
}
/**
 * Response containing multiple rows (for unary Query RPC)
 *
 * @generated from protobuf message torii.sinks.sql.QueryResponse
 */
export interface QueryResponse {
    /**
     * All rows in the result set
     *
     * @generated from protobuf field: repeated torii.sinks.sql.QueryRow rows = 1
     */
    rows: QueryRow[];
    /**
     * Total number of rows returned
     *
     * @generated from protobuf field: int32 total_rows = 2
     */
    total_rows: number;
}
/**
 * Request to get the database schema
 *
 * @generated from protobuf message torii.sinks.sql.GetSchemaRequest
 */
export interface GetSchemaRequest {
    /**
     * Optional: filter by table name
     *
     * @generated from protobuf field: optional string table_name = 1
     */
    table_name?: string;
}
/**
 * Schema information for a single table
 *
 * @generated from protobuf message torii.sinks.sql.TableSchema
 */
export interface TableSchema {
    /**
     * Table name
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * Column definitions (name -> type)
     *
     * @generated from protobuf field: map<string, string> columns = 2
     */
    columns: {
        [key: string]: string;
    };
}
/**
 * Response containing schema information
 *
 * @generated from protobuf message torii.sinks.sql.GetSchemaResponse
 */
export interface GetSchemaResponse {
    /**
     * List of tables and their schemas
     *
     * @generated from protobuf field: repeated torii.sinks.sql.TableSchema tables = 1
     */
    tables: TableSchema[];
}
/**
 * Request to subscribe to SQL events (inserts/updates)
 *
 * @generated from protobuf message torii.sinks.sql.SqlSubscribeRequest
 */
export interface SqlSubscribeRequest {
    /**
     * Client ID for tracking
     *
     * @generated from protobuf field: string client_id = 1
     */
    client_id: string;
    /**
     * Optional filters
     *
     * @generated from protobuf field: optional string table = 2
     */
    table?: string;
    /**
     * @generated from protobuf field: optional string operation = 3
     */
    operation?: string; // "insert", "update", etc.
}
/**
 * Real-time SQL operation update
 *
 * @generated from protobuf message torii.sinks.sql.SqlOperationUpdate
 */
export interface SqlOperationUpdate {
    /**
     * The SQL operation that occurred
     *
     * @generated from protobuf field: torii.sinks.sql.SqlOperation operation = 1
     */
    operation?: SqlOperation;
    /**
     * Timestamp of the update
     *
     * @generated from protobuf field: int64 timestamp = 2
     */
    timestamp: bigint;
}
// @generated message type with reflection information, may provide speed optimized methods
class Felt252$Type extends MessageType<Felt252> {
    constructor() {
        super("torii.sinks.sql.Felt252", [
            { no: 1, name: "value", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Felt252>): Felt252 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Felt252>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Felt252): Felt252 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes value */ 1:
                    message.value = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Felt252, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes value = 1; */
        if (message.value.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message torii.sinks.sql.Felt252
 */
export const Felt252 = new Felt252$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SqlOperation$Type extends MessageType<SqlOperation> {
    constructor() {
        super("torii.sinks.sql.SqlOperation", [
            { no: 1, name: "table", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "operation", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "value", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SqlOperation>): SqlOperation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.table = "";
        message.operation = "";
        message.value = 0n;
        if (value !== undefined)
            reflectionMergePartial<SqlOperation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SqlOperation): SqlOperation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string table */ 1:
                    message.table = reader.string();
                    break;
                case /* string operation */ 2:
                    message.operation = reader.string();
                    break;
                case /* uint64 value */ 3:
                    message.value = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SqlOperation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string table = 1; */
        if (message.table !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.table);
        /* string operation = 2; */
        if (message.operation !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.operation);
        /* uint64 value = 3; */
        if (message.value !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message torii.sinks.sql.SqlOperation
 */
export const SqlOperation = new SqlOperation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SqlFilter$Type extends MessageType<SqlFilter> {
    constructor() {
        super("torii.sinks.sql.SqlFilter", [
            { no: 1, name: "table", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "block_number_gte", kind: "scalar", localName: "block_number_gte", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "block_number_lte", kind: "scalar", localName: "block_number_lte", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SqlFilter>): SqlFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SqlFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SqlFilter): SqlFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string table */ 1:
                    message.table = reader.string();
                    break;
                case /* optional uint64 block_number_gte */ 2:
                    message.block_number_gte = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 block_number_lte */ 3:
                    message.block_number_lte = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SqlFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string table = 1; */
        if (message.table !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.table);
        /* optional uint64 block_number_gte = 2; */
        if (message.block_number_gte !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.block_number_gte);
        /* optional uint64 block_number_lte = 3; */
        if (message.block_number_lte !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.block_number_lte);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message torii.sinks.sql.SqlFilter
 */
export const SqlFilter = new SqlFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryRequest$Type extends MessageType<QueryRequest> {
    constructor() {
        super("torii.sinks.sql.QueryRequest", [
            { no: 1, name: "query", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "limit", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<QueryRequest>): QueryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.query = "";
        if (value !== undefined)
            reflectionMergePartial<QueryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryRequest): QueryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string query */ 1:
                    message.query = reader.string();
                    break;
                case /* optional int32 limit */ 2:
                    message.limit = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string query = 1; */
        if (message.query !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.query);
        /* optional int32 limit = 2; */
        if (message.limit !== undefined)
            writer.tag(2, WireType.Varint).int32(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message torii.sinks.sql.QueryRequest
 */
export const QueryRequest = new QueryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryRow$Type extends MessageType<QueryRow> {
    constructor() {
        super("torii.sinks.sql.QueryRow", [
            { no: 1, name: "columns", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<QueryRow>): QueryRow {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.columns = {};
        if (value !== undefined)
            reflectionMergePartial<QueryRow>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryRow): QueryRow {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> columns */ 1:
                    this.binaryReadMap1(message.columns, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: QueryRow["columns"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof QueryRow["columns"] | undefined, val: QueryRow["columns"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for torii.sinks.sql.QueryRow.columns");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: QueryRow, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> columns = 1; */
        for (let k of globalThis.Object.keys(message.columns))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.columns[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message torii.sinks.sql.QueryRow
 */
export const QueryRow = new QueryRow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryResponse$Type extends MessageType<QueryResponse> {
    constructor() {
        super("torii.sinks.sql.QueryResponse", [
            { no: 1, name: "rows", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => QueryRow },
            { no: 2, name: "total_rows", kind: "scalar", localName: "total_rows", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<QueryResponse>): QueryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rows = [];
        message.total_rows = 0;
        if (value !== undefined)
            reflectionMergePartial<QueryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryResponse): QueryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated torii.sinks.sql.QueryRow rows */ 1:
                    message.rows.push(QueryRow.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 total_rows */ 2:
                    message.total_rows = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated torii.sinks.sql.QueryRow rows = 1; */
        for (let i = 0; i < message.rows.length; i++)
            QueryRow.internalBinaryWrite(message.rows[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 total_rows = 2; */
        if (message.total_rows !== 0)
            writer.tag(2, WireType.Varint).int32(message.total_rows);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message torii.sinks.sql.QueryResponse
 */
export const QueryResponse = new QueryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSchemaRequest$Type extends MessageType<GetSchemaRequest> {
    constructor() {
        super("torii.sinks.sql.GetSchemaRequest", [
            { no: 1, name: "table_name", kind: "scalar", localName: "table_name", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetSchemaRequest>): GetSchemaRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetSchemaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSchemaRequest): GetSchemaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string table_name */ 1:
                    message.table_name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSchemaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string table_name = 1; */
        if (message.table_name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.table_name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message torii.sinks.sql.GetSchemaRequest
 */
export const GetSchemaRequest = new GetSchemaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TableSchema$Type extends MessageType<TableSchema> {
    constructor() {
        super("torii.sinks.sql.TableSchema", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "columns", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<TableSchema>): TableSchema {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.columns = {};
        if (value !== undefined)
            reflectionMergePartial<TableSchema>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TableSchema): TableSchema {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* map<string, string> columns */ 2:
                    this.binaryReadMap2(message.columns, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: TableSchema["columns"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TableSchema["columns"] | undefined, val: TableSchema["columns"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for torii.sinks.sql.TableSchema.columns");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: TableSchema, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* map<string, string> columns = 2; */
        for (let k of globalThis.Object.keys(message.columns))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.columns[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message torii.sinks.sql.TableSchema
 */
export const TableSchema = new TableSchema$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSchemaResponse$Type extends MessageType<GetSchemaResponse> {
    constructor() {
        super("torii.sinks.sql.GetSchemaResponse", [
            { no: 1, name: "tables", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TableSchema }
        ]);
    }
    create(value?: PartialMessage<GetSchemaResponse>): GetSchemaResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tables = [];
        if (value !== undefined)
            reflectionMergePartial<GetSchemaResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSchemaResponse): GetSchemaResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated torii.sinks.sql.TableSchema tables */ 1:
                    message.tables.push(TableSchema.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSchemaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated torii.sinks.sql.TableSchema tables = 1; */
        for (let i = 0; i < message.tables.length; i++)
            TableSchema.internalBinaryWrite(message.tables[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message torii.sinks.sql.GetSchemaResponse
 */
export const GetSchemaResponse = new GetSchemaResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SqlSubscribeRequest$Type extends MessageType<SqlSubscribeRequest> {
    constructor() {
        super("torii.sinks.sql.SqlSubscribeRequest", [
            { no: 1, name: "client_id", kind: "scalar", localName: "client_id", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "table", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "operation", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SqlSubscribeRequest>): SqlSubscribeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.client_id = "";
        if (value !== undefined)
            reflectionMergePartial<SqlSubscribeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SqlSubscribeRequest): SqlSubscribeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string client_id */ 1:
                    message.client_id = reader.string();
                    break;
                case /* optional string table */ 2:
                    message.table = reader.string();
                    break;
                case /* optional string operation */ 3:
                    message.operation = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SqlSubscribeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string client_id = 1; */
        if (message.client_id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.client_id);
        /* optional string table = 2; */
        if (message.table !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.table);
        /* optional string operation = 3; */
        if (message.operation !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.operation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message torii.sinks.sql.SqlSubscribeRequest
 */
export const SqlSubscribeRequest = new SqlSubscribeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SqlOperationUpdate$Type extends MessageType<SqlOperationUpdate> {
    constructor() {
        super("torii.sinks.sql.SqlOperationUpdate", [
            { no: 1, name: "operation", kind: "message", T: () => SqlOperation },
            { no: 2, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SqlOperationUpdate>): SqlOperationUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<SqlOperationUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SqlOperationUpdate): SqlOperationUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* torii.sinks.sql.SqlOperation operation */ 1:
                    message.operation = SqlOperation.internalBinaryRead(reader, reader.uint32(), options, message.operation);
                    break;
                case /* int64 timestamp */ 2:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SqlOperationUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* torii.sinks.sql.SqlOperation operation = 1; */
        if (message.operation)
            SqlOperation.internalBinaryWrite(message.operation, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 timestamp = 2; */
        if (message.timestamp !== 0n)
            writer.tag(2, WireType.Varint).int64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message torii.sinks.sql.SqlOperationUpdate
 */
export const SqlOperationUpdate = new SqlOperationUpdate$Type();
/**
 * @generated ServiceType for protobuf service torii.sinks.sql.SqlSink
 */
export const SqlSink = new ServiceType("torii.sinks.sql.SqlSink", [
    { name: "Query", options: {}, I: QueryRequest, O: QueryResponse },
    { name: "StreamQuery", serverStreaming: true, options: {}, I: QueryRequest, O: QueryRow },
    { name: "GetSchema", options: {}, I: GetSchemaRequest, O: GetSchemaResponse },
    { name: "Subscribe", serverStreaming: true, options: {}, I: SqlSubscribeRequest, O: SqlOperationUpdate }
]);
