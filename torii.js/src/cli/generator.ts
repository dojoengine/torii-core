import { mkdir, writeFile } from 'fs/promises';
import { join } from 'path';

export interface MethodDefinition {
  name: string;
  inputType: string;
  outputType: string;
  clientStreaming: boolean;
  serverStreaming: boolean;
}

export interface ServiceDefinition {
  name: string;
  fullName: string;
  package: string;
  methods: MethodDefinition[];
}

export interface GeneratorOptions {
  sdkImport: string; // e.g., "@toriijs/sdk" or "../sdk"
}

const DEFAULT_OPTIONS: GeneratorOptions = {
  sdkImport: '@toriijs/sdk',
};

export async function generateClientCode(
  services: ServiceDefinition[],
  outputDir: string,
  options: Partial<GeneratorOptions> = {}
): Promise<void> {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  await mkdir(outputDir, { recursive: true });

  // Deduplicate services by fullName
  const uniqueServices = new Map<string, ServiceDefinition>();
  for (const service of services) {
    if (!uniqueServices.has(service.fullName)) {
      uniqueServices.set(service.fullName, service);
    }
  }
  const deduplicatedServices = Array.from(uniqueServices.values());

  for (const service of deduplicatedServices) {
    const clientCode = generateServiceClient(service, opts);
    const fileName = `${service.name}Client.ts`;
    const filePath = join(outputDir, fileName);
    await writeFile(filePath, clientCode);
    console.log(`  Generated: ${fileName}`);
  }

  const indexCode = generateIndex(deduplicatedServices);
  await writeFile(join(outputDir, 'index.ts'), indexCode);
  console.log(`  Generated: index.ts`);
}

function generateServiceClient(
  service: ServiceDefinition,
  options: GeneratorOptions
): string {
  const className = `${service.name}Client`;

  const methods = service.methods
    .map((method) => {
      const methodName = lowerFirst(method.name);
      const rpcPath = `/${service.fullName}/${method.name}`;

      if (method.serverStreaming && !method.clientStreaming) {
        return `
  /**
   * ${method.name} - Server streaming RPC
   */
  async *${methodName}(
    request: Record<string, unknown> = {},
    options?: CallOptions
  ): AsyncGenerator<Record<string, unknown>> {
    yield* this.streamCall('${rpcPath}', request, options);
  }

  /**
   * ${method.name} with callbacks - Server streaming RPC
   */
  async ${methodName}WithCallbacks(
    request: Record<string, unknown>,
    onMessage: (message: Record<string, unknown>) => void,
    onError?: (error: Error) => void,
    onConnected?: () => void
  ): Promise<() => void> {
    return this.subscribeWithCallbacks('${rpcPath}', request, onMessage, onError, onConnected);
  }`;
      } else if (method.clientStreaming && method.serverStreaming) {
        return `
  /**
   * ${method.name} - Bidirectional streaming RPC (not supported in gRPC-Web)
   */
  ${methodName}(): never {
    throw new Error('Bidirectional streaming not supported in gRPC-Web');
  }`;
      } else {
        return `
  /**
   * ${method.name} - Unary RPC
   */
  async ${methodName}(
    request: Record<string, unknown> = {},
    options?: CallOptions
  ): Promise<Record<string, unknown>> {
    return this.unaryCall('${rpcPath}', request, options);
  }`;
      }
    })
    .join('\n');

  return `// Generated by torii.js CLI
// Service: ${service.fullName}

import { BaseSinkClient, type CallOptions } from '${options.sdkImport}';

export class ${className} extends BaseSinkClient {
${methods}
}
`;
}

function generateIndex(services: ServiceDefinition[]): string {
  const exports = services
    .map((s) => `export { ${s.name}Client } from './${s.name}Client';`)
    .join('\n');

  return `// Generated by torii.js CLI
${exports}
`;
}

function lowerFirst(str: string): string {
  return str.charAt(0).toLowerCase() + str.slice(1);
}
