import { mkdir, writeFile } from 'fs/promises';
import { join, dirname } from 'path';

export interface MethodDefinition {
  name: string;
  inputType: string;
  outputType: string;
  clientStreaming: boolean;
  serverStreaming: boolean;
}

export interface ServiceDefinition {
  name: string;
  fullName: string;
  package: string;
  methods: MethodDefinition[];
}

export async function generateClientCode(
  services: ServiceDefinition[],
  outputDir: string
): Promise<void> {
  await mkdir(outputDir, { recursive: true });

  // Deduplicate services by fullName
  const uniqueServices = new Map<string, ServiceDefinition>();
  for (const service of services) {
    if (!uniqueServices.has(service.fullName)) {
      uniqueServices.set(service.fullName, service);
    }
  }
  const deduplicatedServices = Array.from(uniqueServices.values());

  for (const service of deduplicatedServices) {
    const clientCode = generateServiceClient(service);
    const fileName = `${camelToKebab(service.name)}.client.ts`;
    const filePath = join(outputDir, fileName);
    await writeFile(filePath, clientCode);
    console.log(`  Generated: ${fileName}`);
  }

  const indexCode = generateIndex(deduplicatedServices);
  await writeFile(join(outputDir, 'index.ts'), indexCode);
  console.log(`  Generated: index.ts`);

  const toriiClientCode = generateToriiClient(deduplicatedServices);
  await writeFile(join(outputDir, 'ToriiClient.ts'), toriiClientCode);
  console.log(`  Generated: ToriiClient.ts`);
}

function generateServiceClient(service: ServiceDefinition): string {
  const className = `${service.name}Client`;
  const servicePath = service.fullName.replace(/\./g, '/');

  const methods = service.methods
    .map((method) => {
      const methodName = lowerFirst(method.name);
      const rpcPath = `/${service.fullName}/${method.name}`;

      if (method.serverStreaming && !method.clientStreaming) {
        return `
  async *${methodName}(
    request: Record<string, unknown>,
    options?: CallOptions
  ): AsyncGenerator<Record<string, unknown>> {
    const call = this.makeServerStreamingCall('${rpcPath}', request, options);
    for await (const response of call) {
      yield response;
    }
  }`;
      } else if (method.clientStreaming && method.serverStreaming) {
        return `
  ${methodName}(
    options?: CallOptions
  ): {
    send: (request: Record<string, unknown>) => void;
    responses: AsyncGenerator<Record<string, unknown>>;
    close: () => void;
  } {
    return this.makeBidiStreamingCall('${rpcPath}', options);
  }`;
      } else {
        return `
  async ${methodName}(
    request: Record<string, unknown> = {},
    options?: CallOptions
  ): Promise<Record<string, unknown>> {
    return this.makeUnaryCall('${rpcPath}', request, options);
  }`;
      }
    })
    .join('\n');

  return `// Generated by torii.js
// Service: ${service.fullName}

export interface CallOptions {
  abort?: AbortSignal;
  timeout?: number;
  headers?: Record<string, string>;
}

export class ${className} {
  private baseUrl: string;

  constructor(baseUrl: string = 'http://localhost:8080') {
    this.baseUrl = baseUrl.replace(/\\/$/, '');
  }

  private async makeUnaryCall(
    path: string,
    request: Record<string, unknown>,
    options?: CallOptions
  ): Promise<Record<string, unknown>> {
    const body = this.encodeMessage(request);

    const response = await fetch(\`\${this.baseUrl}\${path}\`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/grpc-web+proto',
        'Accept': 'application/grpc-web+proto',
        'x-grpc-web': '1',
        ...options?.headers,
      },
      body,
      signal: options?.abort,
    });

    if (!response.ok) {
      throw new Error(\`gRPC call failed: \${response.status} \${response.statusText}\`);
    }

    const responseBody = await response.arrayBuffer();
    return this.decodeMessage(new Uint8Array(responseBody));
  }

  private async *makeServerStreamingCall(
    path: string,
    request: Record<string, unknown>,
    options?: CallOptions
  ): AsyncGenerator<Record<string, unknown>> {
    const body = this.encodeMessage(request);

    const response = await fetch(\`\${this.baseUrl}\${path}\`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/grpc-web+proto',
        'Accept': 'application/grpc-web+proto',
        'x-grpc-web': '1',
        ...options?.headers,
      },
      body,
      signal: options?.abort,
    });

    if (!response.ok) {
      throw new Error(\`gRPC call failed: \${response.status} \${response.statusText}\`);
    }

    const reader = response.body?.getReader();
    if (!reader) throw new Error('No response body');

    let buffer = new Uint8Array(0);

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      const newBuffer = new Uint8Array(buffer.length + value.length);
      newBuffer.set(buffer);
      newBuffer.set(value, buffer.length);
      buffer = newBuffer;

      while (buffer.length >= 5) {
        const messageLength =
          (buffer[1] << 24) | (buffer[2] << 16) | (buffer[3] << 8) | buffer[4];
        const totalLength = 5 + messageLength;

        if (buffer.length < totalLength) break;

        const messageFrame = buffer.slice(0, totalLength);
        buffer = buffer.slice(totalLength);

        if (messageFrame[0] === 0x00) {
          yield this.decodeMessage(messageFrame);
        }
      }
    }
  }

  private makeBidiStreamingCall(
    path: string,
    options?: CallOptions
  ): {
    send: (request: Record<string, unknown>) => void;
    responses: AsyncGenerator<Record<string, unknown>>;
    close: () => void;
  } {
    throw new Error('Bidirectional streaming not supported in gRPC-Web');
  }

  private encodeMessage(message: Record<string, unknown>): Uint8Array {
    const json = JSON.stringify(message);
    const messageBytes = new TextEncoder().encode(json);

    const frame = new Uint8Array(5 + messageBytes.length);
    frame[0] = 0x00;
    const len = messageBytes.length;
    frame[1] = (len >> 24) & 0xff;
    frame[2] = (len >> 16) & 0xff;
    frame[3] = (len >> 8) & 0xff;
    frame[4] = len & 0xff;
    frame.set(messageBytes, 5);

    return frame;
  }

  private decodeMessage(data: Uint8Array): Record<string, unknown> {
    if (data.length < 5) return {};

    const messageLength =
      (data[1] << 24) | (data[2] << 16) | (data[3] << 8) | data[4];
    const message = data.slice(5, 5 + messageLength);

    try {
      const text = new TextDecoder().decode(message);
      return JSON.parse(text);
    } catch {
      return { _raw: Array.from(message) };
    }
  }
${methods}
}
`;
}

function generateIndex(services: ServiceDefinition[]): string {
  const imports = services
    .map((s) => {
      const fileName = camelToKebab(s.name);
      return `export { ${s.name}Client } from './${fileName}.client';`;
    })
    .join('\n');

  return `// Generated by torii.js
${imports}
export { ToriiClient } from './ToriiClient';
`;
}

function generateToriiClient(services: ServiceDefinition[]): string {
  const imports = services
    .map((s) => {
      const fileName = camelToKebab(s.name);
      const clientName = `${s.name}Client`;
      // Use alias to avoid naming conflicts
      const alias = `${s.name}ServiceClient`;
      return `import { ${clientName} as ${alias} } from './${fileName}.client';`;
    })
    .join('\n');

  const properties = services
    .map((s) => {
      const alias = `${s.name}ServiceClient`;
      const propName = lowerFirst(s.name.replace(/Sink$/, ''));
      return `  public readonly ${propName}: ${alias};`;
    })
    .join('\n');

  const initializers = services
    .map((s) => {
      const alias = `${s.name}ServiceClient`;
      const propName = lowerFirst(s.name.replace(/Sink$/, ''));
      return `    this.${propName} = new ${alias}(this.baseUrl);`;
    })
    .join('\n');

  return `// Generated by torii.js
// Aggregated client for all discovered services

${imports}

export interface ToriiClientOptions {
  baseUrl?: string;
}

export class ToriiClient {
  private baseUrl: string;

${properties}

  constructor(options: ToriiClientOptions | string = {}) {
    if (typeof options === 'string') {
      this.baseUrl = options;
    } else {
      this.baseUrl = options.baseUrl ?? 'http://localhost:8080';
    }

${initializers}
  }

  getBaseUrl(): string {
    return this.baseUrl;
  }
}
`;
}

function camelToKebab(str: string): string {
  return str
    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')
    .replace(/([A-Z])([A-Z][a-z])/g, '$1-$2')
    .toLowerCase();
}

function lowerFirst(str: string): string {
  return str.charAt(0).toLowerCase() + str.slice(1);
}
