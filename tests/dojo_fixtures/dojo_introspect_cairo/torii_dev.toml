[fetcher]
type = "jsonrpc"
rpc_url = "http://localhost:5050"
chunk_size = 512

[runtime]
process_events_batch_size = 2560
filter_concurrency = 1

[decoders.introspect]
store_path = "/tmp/local_json"
rpc_url = "http://localhost:5050"

[contracts.world]
address = "0x079b90aa209a333d5c4b2621d121adeecdb7d705c81615a67944d4fb233c9666"
decoders = ["introspect"]

[sinks.sqlite]
type = "sqlite"
label = "sqlite"
database_url = "sqlite:///tmp/torii_core_local.sqlite"
clean_on_start = true

pub impl ModelStorageWorldStorageImpl<M, +Model<M>, +Drop<M>> of ModelStorage<WorldStorage, M> {
    fn read_model<K, +Drop<K>, +Serde<K>>(self: @WorldStorage, keys: K) -> M {
        let mut keys = serialize_inline::<K>(@keys);
        let mut values = IWorldDispatcherTrait::entity(
            *self.dispatcher,
            Model::<M>::selector(*self.namespace_hash),
            ModelIndex::Id(entity_id_from_serialized_keys(keys)),
            Model::<M>::layout(),
        );
        match Model::<M>::from_serialized(keys, values) {
            Option::Some(model) => model,
            Option::None => {
                panic!(
                    "Model: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct.",
                )
            },
        }
    }

    fn read_models<K, +Drop<K>, +Serde<K>>(self: @WorldStorage, keys: Span<K>) -> Array<M> {
        let mut indexes: Array<ModelIndex> = array![];
        let mut serialized_keys: Array<Span<felt252>> = array![];
        for k in keys {
            let sk = serialize_inline::<K>(k);
            serialized_keys.append(sk);
            indexes.append(ModelIndex::Id(entity_id_from_serialized_keys(sk)));
        }

        let all_values = IWorldDispatcherTrait::entities(
            *self.dispatcher,
            Model::<M>::selector(*self.namespace_hash),
            indexes.span(),
            Model::<M>::layout(),
        );

        let mut models: Array<M> = array![];

        let (mut i, len) = (0, indexes.len());
        while i < len {
            match Model::<M>::from_serialized(*serialized_keys[i], *all_values[i]) {
                Option::Some(model) => models.append(model),
                Option::None => {
                    panic!(
                        "Model: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct.",
                    )
                },
            }

            i += 1;
        }
        models
    }

    fn write_model(ref self: WorldStorage, model: @M) {
        IWorldDispatcherTrait::set_entity(
            self.dispatcher,
            Model::<M>::selector(self.namespace_hash),
            ModelIndex::Keys(Model::<M>::serialized_keys(model)),
            Model::<M>::serialized_values(model),
            Model::<M>::layout(),
        );
    }

    fn write_models(ref self: WorldStorage, models: Span<@M>) {
        let mut keys: Array<ModelIndex> = array![];
        let mut values: Array<Span<felt252>> = array![];
        for m in models {
            keys.append(ModelIndex::Keys(Model::<M>::serialized_keys(*m)));
            values.append(Model::<M>::serialized_values(*m));
        }

        IWorldDispatcherTrait::set_entities(
            self.dispatcher,
            Model::<M>::selector(self.namespace_hash),
            keys.span(),
            values.span(),
            Model::<M>::layout(),
        );
    }

    fn erase_model(ref self: WorldStorage, model: @M) {
        IWorldDispatcherTrait::delete_entity(
            self.dispatcher,
            Model::<M>::selector(self.namespace_hash),
            ModelIndex::Id(Model::<M>::entity_id(model)),
            Model::<M>::layout(),
        );
    }

    fn erase_models(ref self: WorldStorage, models: Span<@M>) {
        let mut ids: Array<ModelIndex> = array![];
        for m in models {
            ids.append(ModelIndex::Id(Model::<M>::entity_id(*m)));
        }

        IWorldDispatcherTrait::delete_entities(
            self.dispatcher,
            Model::<M>::selector(self.namespace_hash),
            ids.span(),
            Model::<M>::layout(),
        );
    }

    fn erase_model_ptr(ref self: WorldStorage, ptr: ModelPtr<M>) {
        IWorldDispatcherTrait::delete_entity(
            self.dispatcher,
            Model::<M>::selector(self.namespace_hash),
            ModelIndex::Id(ptr.id),
            Model::<M>::layout(),
        );
    }

    fn read_member<T, +Serde<T>, +DojoStore<T>>(
        self: @WorldStorage, ptr: ModelPtr<M>, field_selector: felt252,
    ) -> T {
        Model::<
            M,
            >::from_serialized_subset::<
            T,
        >(
            IWorldDispatcherTrait::entity(
                *self.dispatcher,
                Model::<M>::selector(*self.namespace_hash),
                ModelIndex::MemberId((ptr.id, field_selector)),
                field_layout_unwrap::<M>(field_selector),
            ),
        )
            .expect('Could not deserialize')
    }

    fn read_member_of_models<T, +Serde<T>, +DojoStore<T>, +Drop<T>>(
        self: @WorldStorage, ptrs: Span<ModelPtr<M>>, field_selector: felt252,
    ) -> Array<T> {
        let mut values: Array<T> = array![];
        for entity in IWorldDispatcherTrait::entities(
            *self.dispatcher,
            Model::<M>::selector(*self.namespace_hash),
            ptrs.to_member_indexes(field_selector),
            field_layout_unwrap::<M>(field_selector),
        ) {
            values
                .append(
                    Model::<M>::from_serialized_subset::<T>(*entity)
                        .expect('Could not deserialize'),
                );
        }
        values
    }


#[test]
fn test_write_member() {
    let mut world = spawn_foo_world();
    let foo = Foo { k1: 1, k2: 2, v1: 3, v2: 4 };
    world.write_model(@foo);
    world.write_member(foo.ptr(), selector!("v1"), 42);
    let foo_read: Foo = world.read_model((foo.k1, foo.k2));
    assert!(foo_read.v1 == 42 && foo_read.v2 == foo.v2);
}
#[test]
fn test_write_members() {
    let mut world = spawn_foo_world();
    let foo = Foo { k1: 1, k2: 2, v1: 3, v2: 4 };
    let foo2 = Foo { k1: 5, k2: 6, v1: 7, v2: 8 };
    world.write_models([@foo, @foo2].span());
    let ptrs = [foo.ptr(), foo2.ptr()].span();
    let v1s = array![42, 43];
    world.write_member_of_models(ptrs, selector!("v1"), v1s.span());
    let v1s_read: Array<u128> = world.read_member_of_models(ptrs, selector!("v1"));
    let v2s_read: Array<u32> = world.read_member_of_models(ptrs, selector!("v2"));
    assert!(v1s_read == v1s);
    assert!(v2s_read == array![foo.v2, foo2.v2]);
}


    fn write_member<T, +Serde<T>, +DojoStore<T>, +Drop<T>>(
        ref self: WorldStorage, ptr: ModelPtr<M>, field_selector: felt252, value: T,
    ) {
        IWorldDispatcherTrait::set_entity(
            self.dispatcher,
            Model::<M>::selector(self.namespace_hash),
            ModelIndex::MemberId((ptr.id, field_selector)),
            Model::<M>::serialized_subset::<T>(@value),
            field_layout_unwrap::<M>(field_selector),
        );
    }

    fn write_member_of_models<T, +Serde<T>, +DojoStore<T>, +Drop<T>>(
        ref self: WorldStorage, ptrs: Span<ModelPtr<M>>, field_selector: felt252, values: Span<T>,
    ) {
        let mut serialized_values = ArrayTrait::<Span<felt252>>::new();
        for value in values {
            serialized_values.append(Model::<M>::serialized_subset::<T>(value));
        }
        IWorldDispatcherTrait::set_entities(
            self.dispatcher,
            Model::<M>::selector(self.namespace_hash),
            ptrs.to_member_indexes(field_selector),
            serialized_values.span(),
            field_layout_unwrap::<M>(field_selector),
        );
    }
 
    fn erase_models_ptrs(ref self: WorldStorage, ptrs: Span<ModelPtr<M>>) {
        let mut indexes: Array<ModelIndex> = array![];
        for ptr in ptrs {
            indexes.append(ModelIndex::Id(*ptr.id));
        }

        IWorldDispatcherTrait::delete_entities(
            self.dispatcher,
            Model::<M>::selector(self.namespace_hash),
            indexes.span(),
            Model::<M>::layout(),
        );
    }

    fn read_schema<T, +Serde<T>, +DojoStore<T>, +Introspect<T>>(
        self: @WorldStorage, ptr: ModelPtr<M>,
    ) -> T {
        Model::<
            M,
            >::from_serialized_subset::<
            T,
        >(
            IWorldDispatcherTrait::entity(
                *self.dispatcher,
                Model::<M>::selector(*self.namespace_hash),
                ModelIndex::Id(ptr.id),
                Introspect::<T>::layout(),
            ),
        )
            .expect('Could not deserialize')
    }

    fn read_schemas<T, +Drop<T>, +Serde<T>, +DojoStore<T>, +Introspect<T>>(
        self: @WorldStorage, ptrs: Span<ModelPtr<M>>,
    ) -> Array<T> {
        let mut values = ArrayTrait::<T>::new();

        for entity in IWorldDispatcherTrait::entities(
            *self.dispatcher,
            Model::<M>::selector(*self.namespace_hash),
            ptrs.to_indexes(),
            Introspect::<T>::layout(),
        ) {
            values
                .append(
                    Model::<M>::from_serialized_subset::<T>(*entity)
                        .expect('Could not deserialize'),
                );
        }
        values
    }

    fn namespace_hash(self: @WorldStorage) -> felt252 {
        *self.namespace_hash
    }


    fn read_member_legacy<T, +Serde<T>>(
        self: @WorldStorage, ptr: ModelPtr<M>, field_selector: felt252,
    ) -> T {
        deserialize_unwrap(
            IWorldDispatcherTrait::entity(
                *self.dispatcher,
                Model::<M>::selector(*self.namespace_hash),
                ModelIndex::MemberId((ptr.id, field_selector)),
                field_layout_unwrap::<M>(field_selector),
            ),
        )
    }

    fn read_member_of_models_legacy<T, +Serde<T>, +Drop<T>>(
        self: @WorldStorage, ptrs: Span<ModelPtr<M>>, field_selector: felt252,
    ) -> Array<T> {
        let mut values: Array<T> = array![];
        for entity in IWorldDispatcherTrait::entities(
            *self.dispatcher,
            Model::<M>::selector(*self.namespace_hash),
            ptrs.to_member_indexes(field_selector),
            field_layout_unwrap::<M>(field_selector),
        ) {
            values.append(deserialize_unwrap(*entity));
        }
        values
    }

    fn write_member_legacy<T, +Serde<T>, +Drop<T>>(
        ref self: WorldStorage, ptr: ModelPtr<M>, field_selector: felt252, value: T,
    ) {
        IWorldDispatcherTrait::set_entity(
            self.dispatcher,
            Model::<M>::selector(self.namespace_hash),
            ModelIndex::MemberId((ptr.id, field_selector)),
            serialize_inline(@value),
            field_layout_unwrap::<M>(field_selector),
        );
    }

    fn write_member_of_models_legacy<T, +Serde<T>, +Drop<T>>(
        ref self: WorldStorage, ptrs: Span<ModelPtr<M>>, field_selector: felt252, values: Span<T>,
    ) {
        let mut serialized_values = ArrayTrait::<Span<felt252>>::new();
        for value in values {
            serialized_values.append(serialize_inline(value));
        }
        IWorldDispatcherTrait::set_entities(
            self.dispatcher,
            Model::<M>::selector(self.namespace_hash),
            ptrs.to_member_indexes(field_selector),
            serialized_values.span(),
            field_layout_unwrap::<M>(field_selector),
        );
    }

    fn read_schema_legacy<T, +Serde<T>, +Introspect<T>>(
        self: @WorldStorage, ptr: ModelPtr<M>,
    ) -> T {
        deserialize_unwrap(
            IWorldDispatcherTrait::entity(
                *self.dispatcher,
                Model::<M>::selector(*self.namespace_hash),
                ModelIndex::Id(ptr.id),
                dojo::meta::layout::build_legacy_layout(Introspect::<T>::layout()),
            ),
        )
    }

    fn read_schemas_legacy<T, +Drop<T>, +Serde<T>, +Introspect<T>>(
        self: @WorldStorage, ptrs: Span<ModelPtr<M>>,
    ) -> Array<T> {
        let mut values = ArrayTrait::<T>::new();

        for entity in IWorldDispatcherTrait::entities(
            *self.dispatcher,
            Model::<M>::selector(*self.namespace_hash),
            ptrs.to_indexes(),
            dojo::meta::layout::build_legacy_layout(Introspect::<T>::layout()),
        ) {
            values.append(deserialize_unwrap(*entity));
        }
        values
    }
}