// Example: HTTP-Only Sink
//
// This demonstrates a sink with HTTP REST endpoints but no gRPC service:
// - In-memory storage
// - Custom HTTP routes
// - No EventBus publishing
// - No gRPC service
//
// Use case: REST API for queries without real-time streaming
//
// Run: cargo run --example http_only_sink

use std::sync::{Arc, RwLock};
use torii::axum::{
    extract::State,
    http::StatusCode,
    routing::{get, post},
    Json, Router,
};
use torii::etl::envelope::{Envelope, TypeId, TypedBody};
use torii::etl::extractor::ExtractionBatch;
use torii::etl::sink::{EventBus, Sink, TopicInfo};
use torii::etl::Decoder;
use torii::{async_trait, run, ToriiConfig};
use anyhow::Result;
use serde::{Deserialize, Serialize};
use starknet::core::types::EmittedEvent;

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// 1. DEFINE EVENT TYPE
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

#[derive(Clone, Serialize, Deserialize)]
pub struct StoredEvent {
    pub id: u64,
    pub from_address: String,
    pub block_number: u64,
    pub timestamp: i64,
}

// TypedBody implementation
impl TypedBody for StoredEvent {
    fn envelope_type_id(&self) -> TypeId {
        TypeId::new("stored.event")
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }

    fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// 2. IN-MEMORY STORE
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

#[derive(Clone)]
pub struct EventStore {
    events: Arc<RwLock<Vec<StoredEvent>>>,
}

impl EventStore {
    pub fn new() -> Self {
        Self {
            events: Arc::new(RwLock::new(Vec::new())),
        }
    }

    pub fn add(&self, event: StoredEvent) {
        self.events.write().unwrap().push(event);
    }

    pub fn get_all(&self) -> Vec<StoredEvent> {
        self.events.read().unwrap().clone()
    }

    pub fn count(&self) -> usize {
        self.events.read().unwrap().len()
    }
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// 3. HTTP-ONLY SINK
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

pub struct HttpSink {
    store: EventStore,
}

impl HttpSink {
    pub fn new() -> Self {
        Self {
            store: EventStore::new(),
        }
    }

    pub fn generate_sample_events() -> Vec<EmittedEvent> {
        use starknet::core::types::Felt;

        vec![
            EmittedEvent {
                from_address: Felt::from_hex("0xaabbccdd").unwrap(),
                keys: vec![Felt::from_hex("0x1").unwrap()],
                data: vec![Felt::from_hex("0x100").unwrap()],
                block_hash: None,
                block_number: None,
                transaction_hash: Felt::ZERO,
            },
            EmittedEvent {
                from_address: Felt::from_hex("0x11223344").unwrap(),
                keys: vec![Felt::from_hex("0x2").unwrap()],
                data: vec![Felt::from_hex("0x200").unwrap()],
                block_hash: None,
                block_number: None,
                transaction_hash: Felt::ZERO,
            },
            EmittedEvent {
                from_address: Felt::from_hex("0x55667788").unwrap(),
                keys: vec![Felt::from_hex("0x3").unwrap()],
                data: vec![Felt::from_hex("0x300").unwrap()],
                block_hash: None,
                block_number: None,
                transaction_hash: Felt::ZERO,
            },
        ]
    }
}

#[async_trait]
impl Sink for HttpSink {
    fn name(&self) -> &str {
        "http"
    }

    fn interested_types(&self) -> Vec<TypeId> {
        vec![TypeId::new("stored.event")]
    }

    fn topics(&self) -> Vec<TopicInfo> {
        // No topics - HTTP only!
        vec![]
    }

    async fn initialize(&mut self, _event_bus: Arc<EventBus>) -> Result<()> {
        tracing::info!("HttpSink initialized (HTTP-only, no EventBus publishing)");
        Ok(())
    }

    async fn process(&self, envelopes: &[Envelope], _batch: &ExtractionBatch) -> Result<()> {
        for envelope in envelopes {
            if envelope.type_id != TypeId::new("stored.event") {
                continue;
            }

            if let Some(stored_event) = envelope.downcast_ref::<StoredEvent>() {
                // Just store it - no EventBus publishing
                self.store.add(stored_event.clone());

                tracing::info!(
                    "ğŸ“¦ Stored event #{} from {} at block {}",
                    stored_event.id,
                    stored_event.from_address,
                    stored_event.block_number
                );
            }
        }

        Ok(())
    }

    fn build_routes(&self) -> Router {
        // HTTP ROUTES - REST API for queries
        Router::new()
            .route("/http/events", get(get_events))
            .route("/http/count", get(get_count))
            .route("/http/clear", post(clear_events))
            .with_state(self.store.clone())
    }
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// 4. HTTP HANDLERS
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

#[derive(Serialize)]
struct EventsResponse {
    events: Vec<StoredEvent>,
    total: usize,
}

async fn get_events(State(store): State<EventStore>) -> Json<EventsResponse> {
    let events = store.get_all();
    let total = events.len();
    Json(EventsResponse { events, total })
}

#[derive(Serialize)]
struct CountResponse {
    count: usize,
}

async fn get_count(State(store): State<EventStore>) -> Json<CountResponse> {
    Json(CountResponse {
        count: store.count(),
    })
}

#[derive(Serialize)]
struct ClearResponse {
    message: String,
    cleared: usize,
}

async fn clear_events(State(store): State<EventStore>) -> (StatusCode, Json<ClearResponse>) {
    let count = store.count();
    store.events.write().unwrap().clear();
    (
        StatusCode::OK,
        Json(ClearResponse {
            message: "Events cleared".to_string(),
            cleared: count,
        }),
    )
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// 5. DECODER
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

pub struct HttpDecoder {
    counter: Arc<std::sync::atomic::AtomicU64>,
}

impl HttpDecoder {
    pub fn new() -> Self {
        Self {
            counter: Arc::new(std::sync::atomic::AtomicU64::new(1)),
        }
    }
}

#[async_trait]
impl Decoder for HttpDecoder {
    async fn decode(&self, events: &[EmittedEvent]) -> Result<Vec<Envelope>> {
        Ok(events
            .iter()
            .map(|event| {
                let id = self
                    .counter
                    .fetch_add(1, std::sync::atomic::Ordering::SeqCst);

                let stored_event = StoredEvent {
                    id,
                    from_address: format!("{:#x}", event.from_address),
                    block_number: event.block_number.unwrap_or(0),
                    timestamp: chrono::Utc::now().timestamp(),
                };

                Envelope::new(
                    format!("http_event_{}", id),
                    Box::new(stored_event),
                    Default::default(),
                )
            })
            .collect())
    }
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// 6. MAIN
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("ğŸš€ Torii HTTP-Only Sink Example\n");
    println!("This sink demonstrates:");
    println!("  âœ“ In-memory storage");
    println!("  âœ“ Custom HTTP REST endpoints");
    println!("  âœ“ No EventBus publishing");
    println!("  âœ“ No gRPC service\n");

    // Create sink and decoder
    let http_sink = HttpSink::new();
    let http_decoder = Arc::new(HttpDecoder::new());

    // Get sample events
    let sample_events = HttpSink::generate_sample_events();
    println!("ğŸ“‹ Loaded {} sample events\n", sample_events.len());

    // Configure Torii
    let config = ToriiConfig::builder()
        .port(8080)
        .host("0.0.0.0".to_string())
        .add_sink_boxed(Box::new(http_sink))
        .add_decoder(http_decoder)
        .with_sample_events(sample_events)
        .cycle_interval(3)
        .events_per_cycle(1)
        .build();

    println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    println!("ğŸ“¦ HTTP-ONLY SINK CONFIGURATION");
    println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    println!("ğŸŒ Server: http://0.0.0.0:8080");
    println!("ğŸ”„ ETL Cycle: {} seconds", config.cycle_interval);
    println!("ğŸ“Š Events/Cycle: {}", config.events_per_cycle);
    println!();
    println!("ğŸ“ Topics: None (HTTP only)");
    println!("ğŸ“¡ gRPC: None (HTTP only)");
    println!("ğŸ”Œ Storage: In-memory");
    println!();
    println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    println!("ğŸ§ª TESTING GUIDE");
    println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    println!();
    println!("ğŸ“¡ HTTP Endpoints:");
    println!("   # Get all events");
    println!("   curl http://localhost:8080/http/events");
    println!();
    println!("   # Get event count");
    println!("   curl http://localhost:8080/http/count");
    println!();
    println!("   # Clear all events");
    println!("   curl -X POST http://localhost:8080/http/clear");
    println!();
    println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    println!("ğŸš€ Starting server...\n");

    run(config).await
}
